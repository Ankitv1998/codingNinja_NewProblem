Question:Rectangular Area
You are given a rectangle in a plane whose sides are parallel to the axes. The coordinates of one of its diagonals are provided to you. You have to print the total area of the rectangle.
The coordinates of the rectangle are provided as four integral values: x1, y1, x2, y2. It is given that x1 < x2 and y1 < y2.


Input format:
The first line of input contains an integer x1 
The second line of input contains an integer y1  
The third line of input contains an integer x2 
The fourth line of input contains an integer y2 
Constraints:
1 <= x1 <= 10
1 <= y1 <= 10
1 <= x2 <= 10
1 <= y2 <= 10 
Time Limit: 1 second
Output format:
The first and only line of output contains the result.  
Sample Input:
1
1
3
3
Sample Output:
4
Explanation:
The given coordinates of the diagonal are (x1,y1) = (1,1) and (x2,y2) = (3, 3). 
The area of the rectangle can then easily be calculated as: 
(3 – 1) * ( 3 – 1) = 2 * 2 = 4 

***************************************************************************************************************************************************************

import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        int x1 = sc.nextInt();
        int y1 = sc.nextInt();
        int x2 = sc.nextInt();
        int y2 = sc.nextInt();
        
        int area = (x2 - x1) * (y2 - y1);
        
        System.out.println(area);
    }
}

***************************************************************************************************************************************************************
***************************************************************************************************************************************************************

Reverse Array Between 2 Index
Given an array ‘ARR’ of size ‘N’. You are also given two indices ‘L’ and ‘R’.
Your task is to reverse the ‘ARR’ from index ‘L’ to ‘R’ inclusive.
Example:
Input:
‘N’ = 3 ‘L’ = 0 ‘R’ = 1 ‘ARR’ = [1, 2, 3]


Output: 
2 1 3

Explanation:

When we reverse the elements between indices 0 and 1 we get the array as 2 1 3.
Input Format:
The first line of input contains an integer ‘T’ denoting the number of test cases.
Then the test case follows.

The first line of each test case contains an integer ‘N’ denoting the number of elements in the array ‘ARR’. 

The second line of each test case contains 2 space-separated integers denoting ‘L’ and ‘R’ respectively.
The second line of each test case contains ‘N' space-separated integers denoting the elements of the array ‘ARR’.
Output format:
For each test case print the array after applying the given operation.
Constraints :
1  <= T <= 10
1  <= N <= 100000
0 <= L, R < N
1 <= ARR[i] <= 1e9
Time Limit: 1 sec
Sample Input 1:
2
3
0 1
1 2 3
2
0 1 
1 2
Sample Output 1:
2 1 3
2 1
Explanation Of Sample Input 1 :
Test 1:
When we reverse the elements between indices 0 and 1 we get the array as 2 1 3.

Test 2:
When we reverse the elements between indices 0 and 1 we get the array as 2 1.
Sample Input 2 :
2
5
0 3
21 6 46 36 10 
10
9 9
21 2 17 39 48 41 44 23 22 7 
Sample Output 2 :
36 46 6 21 10 
21 2 17 39 48 41 44 23 22 7


---------------------------------------------------------------------------------------------------------------------------------------------------------

public class Solution {
    public static int[] reverseBetween(int n, int l, int r, int[] arr) {
        // Reverse the array from index l to r
        int len = (r - l + 1) / 2;
        for (int i = 0; i < len; i++) {
            int temp = arr[l + i];
            arr[l + i] = arr[r - i];
            arr[r - i] = temp;
        }
        return arr;
    }
}


---------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------

Remark Student
Teacher is remarking students on the basis of their score. Criteria for remarking students are as follows:


If the score is greater than 75 to 100 then it will be remarked ‘Distinction’.
If the score is greater than 50 to 75 then it will remarked ‘Average’
If the score is between 35 - 50 then it will be remarked ‘Below Average’.
Input Format:


First line contains an integer n denoting the number of students.

Next n lines contain the score of the student.


Output Format:


Next n lines contain the remark of students.


Constraints:


1<n<=1000

35<=score[i]<=100
Sample Input1:


2

36

78


Sample Output 1:


Below Average

Distinction


Explanation for Sample case 1:


No explanation is required.


Sample Input2:


4

76

63

35

56

Sample Output 2:

Distinction

Average

Below Average

Average


Explanation for Sample case 2:


No Explanation is required.


---------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------
public class Solution {
    public static String remarkStudent(int score) {
        if (score >= 75 && score <= 100) {
            return "Distinction";
        } else if (score >= 50 && score < 75) {
            return "Average";
        } else if (score >= 35 && score < 50) {
            return "Below Average";
        } else {
            return "Fail";
        }
    }
}

---------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------
Nodes without sibling
For a given Binary Tree of type integer, print all the nodes without any siblings.
Input Format:
The first and the only line of input will contain the node data, all separated by a single space. Since -1 is used as an indication whether the left or right node data exist for root, it will not be a part of the node data.
Output Format:
The only line of output prints the node data in a top to down fashion with reference to the root. 
Node data in the left subtree will be printed first and then the right subtree.
A single space will separate them all.
 Constraints:
1 <= N <= 10^5
Where N is the total number of nodes in the binary tree.

Time Limit: 1 second
Sample Input 1:
5 6 10 2 3 -1 -1 -1 -1 -1 9 -1 -1
Sample Output 1:
9    
Sample Input 2:
2 4 5 6 -1 -1 7 20 30 80 90 -1 -1 -1 -1 -1 -1 -1 -1
Sample Output 2:
6 7  
Explanation of Sample Input 2:
The input tree when represented in a two-dimensional plane, it would look like this:     
alt txt

In respect to the root, node data in the left subtree that satisfy the condition of not having a sibling would be 6, taken in a top-down sequence. Similarly, for the right subtree, 7 is the node data without any sibling.

Since we print the siblings in the left-subtree first and then the siblings from the right subtree, taken in a top-down fashion, we print 6 7.


public class Solution {

    public static void printNodesWithoutSibling(BinaryTreeNode<Integer> root) {
        if (root == null) {
            return;
        }

        if (root.left != null && root.right != null) {
            // This node has both left and right children, so recurse on both
            printNodesWithoutSibling(root.left);
            printNodesWithoutSibling(root.right);
        } else if (root.left != null) {
            // This node has a left child only, so recurse on the left child
            System.out.print(root.left.data + " ");
            printNodesWithoutSibling(root.left);
        } else if (root.right != null) {
            // This node has a right child only, so recurse on the right child
            System.out.print(root.right.data + " ");
            printNodesWithoutSibling(root.right);
        }
    }

    public static void main(String[] args) {
        BinaryTreeNode<Integer> root = new BinaryTreeNode<>(2);
        root.left = new BinaryTreeNode<>(4);
        root.right = new BinaryTreeNode<>(5);
        root.left.left = new BinaryTreeNode<>(6);
        root.right.left = new BinaryTreeNode<>(7);
        root.right.left.right = new BinaryTreeNode<>(20);
        root.right.right = new BinaryTreeNode<>(30);
        root.right.right.right = new BinaryTreeNode<>(90);
        root.right.right.left = new BinaryTreeNode<>(80);

        printNodesWithoutSibling(root); // Output: 6 7
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
Check if a Binary Tree is BST
Given a binary tree with N number of nodes, check if that input tree is BST (Binary Search Tree). If yes, return true, return false otherwise.
Note: Duplicate elements should be kept in the right subtree.
Input format :
The first line of input contains data of the nodes of the tree in level order form. The data of the nodes of the tree is separated by space. If any node does not have a left or right child, take -1 in its place. Since -1 is used as an indication whether the left or right nodes exist, therefore, it will not be a part of the data of any node.
Output format :
The first and only line of output contains either true or false.
Constraints :
Time Limit: 1 second
Sample Input 1 :
3 1 5 -1 2 -1 -1 -1 -1
Sample Output 1 :
true
Sample Input 2 :
5 2 10 0 1 -1 15 -1 -1 -1 -1 -1 -1
Sample Output 2 :
false

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

public class Solution {
    public static boolean isBST(BinaryTreeNode<Integer> root) {
        // Call the helper function with minimum and maximum limits
        return isBSTHelper(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
    }

    private static boolean isBSTHelper(BinaryTreeNode<Integer> root, int min, int max) {
        // If the root is null, then it is a valid BST
        if (root == null) {
            return true;
        }

        // If the root's data is outside the given range, then it is not a valid BST
        if (root.data < min || root.data > max) {
            return false;
        }

        // Recursively check the left and right subtrees with updated range limits
        boolean isLeftSubtreeBST = isBSTHelper(root.left, min, root.data - 1);
        boolean isRightSubtreeBST = isBSTHelper(root.right, root.data, max);

        // Return true only if both the subtrees are BSTs
        return isLeftSubtreeBST && isRightSubtreeBST;
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
String Replace character
-----------------------------------------------------------------------------------------------------------------------------------------------------------------

public class Solution {
    public static String replaceCharacter(String input, char c1, char c2) {
        // Base case
        if (input.length() == 0) {
            return input;
        }

        // Recursive call
        char firstChar = input.charAt(0);
        String remainingString = input.substring(1);
        String smallOutput = replaceCharacter(remainingString, c1, c2);

        // Calculation and return
        if (firstChar == c1) {
            return c2 + smallOutput;
        } else {
            return firstChar + smallOutput;
        }
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
Print Node sum S
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------

import java.util.Stack;

public class Solution {

    public static void printNodesSumToS(BinaryTreeNode<Integer> root, int S) {
        Stack<BinaryTreeNode<Integer>> stack1 = new Stack<>();
        Stack<BinaryTreeNode<Integer>> stack2 = new Stack<>();
        BinaryTreeNode<Integer> curr1 = root;
        BinaryTreeNode<Integer> curr2 = root;

        // Push nodes from leftmost to smallest in stack1
        while (curr1 != null) {
            stack1.push(curr1);
            curr1 = curr1.left;
        }

        // Push nodes from rightmost to largest in stack2
        while (curr2 != null) {
            stack2.push(curr2);
            curr2 = curr2.right;
        }

        // Traverse through the two stacks
        while (!stack1.isEmpty() && !stack2.isEmpty() && stack1.peek().data < stack2.peek().data) {
            BinaryTreeNode<Integer> node1 = stack1.peek();
            BinaryTreeNode<Integer> node2 = stack2.peek();

            int sum = node1.data + node2.data;

            // If sum is less than S, then move to next larger node in stack1
            if (sum < S) {
                curr1 = stack1.pop().right;
                while (curr1 != null) {
                    stack1.push(curr1);
                    curr1 = curr1.left;
                }
            }
            // If sum is greater than S, then move to next smaller node in stack2
            else if (sum > S) {
                curr2 = stack2.pop().left;
                while (curr2 != null) {
                    stack2.push(curr2);
                    curr2 = curr2.right;
                }
            }
            // If sum is equal to S, then print the pair of nodes
            else {
                System.out.println(node1.data + " " + node2.data);
                curr1 = stack1.pop().right;
                curr2 = stack2.pop().left;
                while (curr1 != null) {
                    stack1.push(curr1);
                    curr1 = curr1.left;
                }
                while (curr2 != null) {
                    stack2.push(curr2);
                    curr2 = curr2.right;
                }
            }
        }
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
Smallest Different Pair
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------


import java.util.Arrays;

public class Solution {
    public static int smallestDifferencePair(int[] arr1, int n, int[] arr2, int m) {
        Arrays.sort(arr1);
        Arrays.sort(arr2);
        int i = 0, j = 0, minDiff = Integer.MAX_VALUE;
        while (i < n && j < m) {
            int diff = Math.abs(arr1[i] - arr2[j]);
            minDiff = Math.min(minDiff, diff);
            if (arr1[i] < arr2[j]) {
                i++;
            } else {
                j++;
            }
        }
        return minDiff;
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
Duplicate Number In array
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------

public class Solution{  
    
    public static int duplicateNumber(int arr[]) {
        int n = arr.length;
        int sum = 0;
        for (int i = 0; i < n; i++) {
            sum += arr[i];
        }
        int actualSum = ((n - 1) * (n - 2)) / 2;
        int duplicateNumber = sum - actualSum;
        return duplicateNumber;
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
Insertion and Duplicate Binary Tree
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------


import java.util.LinkedList;
import java.util.Queue;

class BinaryTreeNode<T> {
    T data;
    BinaryTreeNode<T> left;
    BinaryTreeNode<T> right;

    public BinaryTreeNode(T data) {
        this.data = data;
        this.left = null;
        this.right = null;
    }
}

public class Solution {
    public static void printLevelWise(BinaryTreeNode<Integer> root) {
        if (root == null) return;

        
        queue.add(root);

        while (!queue.isEmpty()) {
            BinaryTreeNode<Integer> node = queue.poll();
            String nodeInfo = node.data + ":";
            if (node.left != null) {
                queue.add(node.left);
                nodeInfo += "L:" + node.left.data;
            } else {
                nodeInfo += "L:-1";
            }
            if (node.right != null) {
                queue.add(node.right);
                nodeInfo += ",R:" + node.right.data;
            } else {
                nodeInfo += ",R:-1";
            }
            System.out.println(nodeInfo);
        }
    }

    public static void main(String[] args) {
        // sample input: 8 3 10 1 6 -1 14 -1 -1 4 7 13 -1 -1 -1 -1 -1 -1 -1
        BinaryTreeNode<Integer> root = new BinaryTreeNode<>(8);
        root.left = new BinaryTreeNode<>(3);
        root.right = new BinaryTreeNode<>(10);
        root.left.left = new BinaryTreeNode<>(1);
        root.left.right = new BinaryTreeNode<>(6);
        root.right.right = new BinaryTreeNode<>(14);
        root.left.right.left = new BinaryTreeNode<>(4);
        root.left.right.right = new BinaryTreeNode<>(7);
        root.right.right.left = new BinaryTreeNode<>(13);

        printLevelWise(root);
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------

Insert Duplicate Node in Binary Tree
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
public static void insertDuplicateNode(BinaryTreeNode<Integer> root) {
    if (root == null) {
        return;
    }
    insertDuplicateNode(root.left);
    insertDuplicateNode(root.right);
    BinaryTreeNode<Integer> newNode = new BinaryTreeNode<Integer>(root.data);
    newNode.left = root.left;
    root.left = newNode;
}
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------


Nodes Without Siblings
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------

public class Solution {
    public static void printNodesWithoutSibling(BinaryTreeNode<Integer> root) {
        // If root is null, return
        if (root == null) {
            return;
        }
        
        // If the root has only one child, print the data of that child
        if (root.left == null && root.right != null) {
            System.out.print(root.right.data + " ");
        }
        if (root.left != null && root.right == null) {
            System.out.print(root.left.data + " ");
        }
        
        // Recursively call the function for the left and right subtree
        printNodesWithoutSibling(root.left);
        printNodesWithoutSibling(root.right);
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
Quick Sort

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
public class Solution {
    public static void quickSort(int[] input) {
        int si = 0;
        int ei = input.length - 1;
        quickSort(input, si, ei);
    }

    private static void quickSort(int[] input, int si, int ei) {
        if (si >= ei) {
            return;
        }

        int pivotIndex = partition(input, si, ei);
        quickSort(input, si, pivotIndex - 1);
        quickSort(input, pivotIndex + 1, ei);
    }

    private static int partition(int[] input, int si, int ei) {
        int pivot = input[si];
        int smallerCount = 0;

        for (int i = si + 1; i <= ei; i++) {
            if (input[i] <= pivot) {
                smallerCount++;
            }
        }

        int pivotIndex = si + smallerCount;
        int temp = input[si];
        input[si] = input[pivotIndex];
        input[pivotIndex] = temp;

        int i = si;
        int j = ei;

        while (i <= pivotIndex && j >= pivotIndex) {
            if (input[i] <= pivot) {
                i++;
            } else if (input[j] > pivot) {
                j--;
            } else {
                int temp2 = input[i];
                input[i] = input[j];
                input[j] = temp2;
                i++;
                j--;
            }
        }

        return pivotIndex;
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Reverse String 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------

class Solution {
    public void reverseString(char[] s) {
        int i=0;
        int j=s.length-1;
        while(i<j)
        {
            char temp=s[i];
            s[i]=s[j];
            s[j]=temp;
            i++;
            j--;
        }
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
Maximum Subarray
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------


class Solution 
{
    public int maxSubArray(int[] nums)
 {
        int maxSoFar=nums[0];
        int maxEndingHere=nums[0];
        for(int i=1 ; i<nums.length;i++)
        {
            maxEndingHere=Math.max(maxEndingHere+nums[i],nums[i]);
            maxSoFar=Math.max(maxSoFar, maxEndingHere);
        }
        return maxSoFar;
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
Contains Duplicate
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------


import java.util.*;
class Solution 
{
    public boolean containsDuplicate(int[] nums)
    {
        Set<Integer> set = new HashSet<Integer>();
        for(int num : nums)
        {
            if(set.contains(num))
            {
                return true;
            }
            set.add(num);
        }
        return false;
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
Search in Rotated Sorted Array
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------


class Solution {
    public int search(int[] nums, int target) 
    {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) 
            {
                return mid;
            }
            if (nums[left] <= nums[mid])
             { // left half is sorted
                if (nums[left] <= target && target < nums[mid]) 
                {
                    right = mid - 1;
                } else
                 {
                    left = mid + 1;
                }
            } else
             { // right half is sorted
                if (nums[mid] <= target && target <= nums[right]) 
                {
                    left = mid + 1;
                } else 
                {
                    right = mid - 1;
                }
            }
        }
        return -1;
    }
}


-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
Next Permutation
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------


class Solution {
    public void nextPermutation(int[] nums) {
        int i = nums.length - 2;
        while (i >= 0 && nums[i] >= nums[i + 1]) {
            i--;
        }
         if (i >= 0) {
            int j = nums.length - 1;
            while (nums[j] <= nums[i]) {
                j--;
            }
            swap(nums, i, j);
        }
        reverse(nums, i + 1);
    }
    
    
    private void swap(int[] nums, int i, int j)
     {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
    
    private void reverse(int[] nums, int start)
     {
        int i = start, j = nums.length - 1;
        while (i < j) {
            swap(nums, i, j);
            i++;
            j--;
        }
    }
}


-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
Best time to Buy and Sell Stock
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------

class Solution {
    public int maxProfit(int[] prices) {
        int minPrice = Integer.MAX_VALUE;
        int maxProfit = 0;
        
        for (int i = 0; i < prices.length; i++) {
            if (prices[i] < minPrice) {
                minPrice = prices[i];
            } else if (prices[i] - minPrice > maxProfit) {
                maxProfit = prices[i] - minPrice;
            }
        }
        
        return maxProfit;
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
